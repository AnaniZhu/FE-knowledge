# HTTP

## TCP

### 三次握手

#### 为什么要三次握手?

确认客户端和服务端发送和接收能力是否正常

#### 流程

1. 第一次握手: 客户端向服务端发送 `SYN = 1, seq = x`，客户端处于 `SYN_SEND` 状态。

2. 第二次握手: 服务端接收到后向客户端发送 `SYN = 1, ACK = 1, seq = y, ack = x + 1`，服务端处于 `SYN_REVD` 状态。（此连接会进入半连接队列）

3. 第三次握手: 客户端发送 `ACK = 1, ack = y + 1`，此时客户端处于 `ESTABLISHED` 状态，当服务端接收到 `ACK` 报文后，也处于 `ESTABLISHED` 状态。（此连接在服务端会进入全连接队列）

   - 当客户端超过指定时间还没有发送 `ACK` （或者丢包）时，处于 `SYN_REVD` 的服务端会重新向客户端发送 `SYN` + `ACK` ，直到达到最大重传次数后，系统（服务端）将该条连接从半连接队列中移除。



> 只有第三次握手才可以携带数据。(TCP 规定含有 `SYN` 标志位的握手不允许携带数据)
>
> 第三次握手时客户端已经处于 `ESTABLISHED` 状态，确保服务端发送和接受能力都正常，处于相对安全的一个状态。
>
> 如果前两次握手允许携带数据，一旦有人存有恶意攻击的想法，只需要在第一次握手发送大量的数据，服务端就会花大量的时间和内存去处理这些数据，增加服务器压力甚至崩溃。

#### SYNC Flood 攻击

....

### 四次挥手

#### 流程

假如是客户端先发起关闭请求。四次挥手的过程如下：

1. 第一次挥手: 客户端向服务端发送 `FIN`，客户端处于 `FIN_WAIT1` 状态
2. 第二次挥手: 服务端向客户端发送 `ACK`，服务端处于 `CLOSE_WAIT` 状态，客户端接收到回应后，处于 `FIN_WAIT2` 状态
3. 第三次挥手: 当服务端打算断开连接了，会向客户端发送 `FIN` + `ACK`, 服务端处于 `LAST_ACK` 状态
4. 第四次挥手: 客户端接收到服务端响应，向服务端发送 `ACK`, 随后:
   - 客户端进入 `TIME_WAIT` 状态，在指定延时（`2MSL`）后，释放连接，进入 `CLOSED` 状态
   - 服务端接收到客户端的应答，进入 `CLOSED` 状态



> 当第三次挥手后，服务端超过指定时间后还未接收到客户端的应答，会重新发送 `FIN` + `ACK`，直到达到最大重传次数。当客户端接收到服务端的重传信息，会重传一次 `ACK`，同时重新启动时间等待器。
>
> 上述情况也说明了为什么客户端要进入 `TIME_WAIT` 状态的原因：如果不进入等待态直接关闭，恰好这次发送出现了丢包，服务端没接收到会进行重发，这个时候客户端已经关闭无法做出响应，服务端会重发直到达到最大上限后再关闭，这会浪费服务端时间与资源...



#### 为什么要四次挥手?

Q: 为什么不能像三次握手一样，将第二次挥手和第三次挥手的 `ACK` + `FIN` 合并为一次发送?

A: 当客户端向服务端发送 `FIN` 表示需要断开连接时，服务端可能还在发送资源中（断开连接前客户端向服务端请求了资源，这个资源还没发送完），所以要服务端会先发一个 `ACK` 表示确认收到，等到服务端认为达到了关闭的条件（比如`资源全部发送完成` 或者 `中断发送资源且做完清理操作后`）之后主动向客户端发送关闭确认。



#### 为什么要等待 2MSL 而不是 1MSL

- 1 个 `MSL` 保证第四次挥手的 `ACK` 可以发送到对端
- 1 个 `MSL` 保证对端的重传报文可以到达



![三次握手&四次挥手](https://pic4.zhimg.com/v2-67515121626493be9b645be76534007f_r.jpg)



### 三次握手 & 四次挥手参考

- [面试官，不要再问我三次握手和四次挥手](https://zhuanlan.zhihu.com/p/86426969)
- [跟着动画来学习TCP三次握手和四次挥手](https://juejin.im/post/5b29d2c4e51d4558b80b1d8c)

## http

### 特点

- 简单快速
  - 请求时只需发送请求方法和路径
- 灵活
  - 可以传输多种格式的数据
- 无连接
  - 每进行一次 `HTTP` 通信，就要断开一次 `TCP` 连接
- 无状态
  - 没有记忆能力，无法根据之前状态处理本次请求

### 报文组成

- 请求/响应行
  - 请求行: 请求方法，Path, http 版本
  - 响应行: http 版本，状态码，状态码对应的消息
- 请求/响应头
- 空行
- 请求/响应体

### 请求头 & 响应头类型

- 通用首部
- 实体首部
- 请求/响应首部

### 状态码

#### 10x

此类响应为临时响应。代表响应成功，请求继续。

- `101` `Switch Protocols` 改变协议，比如 `http` 升级为 `websocket`

#### 20x

- `200` 请求成功
- `204` 服务端请求成功，但响应报文中不包含实体的主体部分。
- `206` 表明客户端进行了范围请求，服务端成功返回指定范围的实体内容

#### 30x

- `301` 永久重定向
- `302` 临时重定向
- `303` 临时重定向。但是标明重定向的请求必须为 `GET`
- `304` 表明服务端资源未修改，告知客户端可继续使用缓存
- `307` 临时重定向。但规定重定向请求方法不能从 `POST` 变成 `GET`。
  - 因为大部分浏览器在重定向时(`301`, `302`, `303`) 会将 `POST` 改为 `GET`

#### 40x

- `400` `Bad Request`。请求报文存在语法错误。
- `401` `unauthorize`。发送的请求需要通过 `HTTP` 权限认证 (`Basic` | `username` `password`)
- `403` `Forbidden`。请求被拒绝
- `404` `Not Found`。资源不存在
- `405` `Method Not Allowed`。请求方法不允许

#### 50x

- `500` 服务端遇到了未知错误
- `502` 网关错误
- `503` 服务不可用（服务器维护中或负载过重）
- `504` 网关超时


### 请求方法

#### GET & POST 区别

- `GET` 请求参数只能存放在 `url` 里），安全性更低，长度受浏览器限制(`2k`)。`POST` 参数放在响应主体里，响应主体长度不受限制。
  - 协议标准并未规定 `GET`/`POST` 参数必须放在哪里，无论 `GET` `POST` 都可以放在 `url`、`body` 中，只是大部分都会遵循 `REST`最佳实践。
  - 部分浏览器也不支持 `GET` 参数放入 `body` 中
- `GET` 无副作用，是幂等的。`POST` 有副作用，浏览器后退时会再次提交请求。
- `GET`默认会被浏览器缓存，`POST` 需要配置 `Cache-Control` 或 `Expires`(大部分浏览器不支持缓存 `POST`)
- 部分浏览器(`chorme` 不会)中 `GET` 请求比 `POST` 更快。部分浏览器 `GET` 请求只发一次 `TCP` 数据包，`POST` 会发两个 `TCP` 数据包，先发 `header`，服务器响应 `100`, 再发 `body`。
- `GET` 参数数据类型只接受 ASCII 字符，而 `POST` 无限制

都是明文传输。

#### GET & POST 区别 - 参考链接

- [都 2019 年了，还问 GET 和 POST 的区别](https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/)
- [99%的人理解错 HTTP 中 GET 与 POST 的区别](https://www.oschina.net/news/77354/http-get-post-different)
- [GET 和 POST 到底有什么区别？](https://www.zhihu.com/question/28586791)

#### PUT & PATCH 区别

`PUT` 是全量更新, `PATCH` 是部分更新

### 请求体

### 版本迭代

#### v0.9

- 只支持 `GET` 方法
- 不支持协议头（请求头/响应头）
- 响应仅支持纯文本 HTML

#### v1.0

- 增加 `POST` `HEAD` 方法
- 支持请求头和响应头
- 响应对象不仅限于超文本
- 响应对象以一个响应状态行开始
- 每次请求结束后 `TCP` 连接默认会断开，再次请求需要再次建立 `TCP` 连接
  - 解决方案: 主动设置 `connection: keep-alive`

#### v1.1

- 默认启用长连接: `connection: keep-alive`，多次连接会复用 `TCP` 连接，除非设置 `connection: close` 标识不再复用该连接
- 管道机制(`pipeline`)。多个请求会通过一个 `TCP` 链接并发出去，不过服务端还是依次响应并返回（队头阻塞）。浏览器限制为 5~8 个并发量
- 新增 `PUT` `PATCH` `OPTIONS` `DELETE` `TRACE` `CONNECT` 方法
- 支持响应分块传输。通过 chunked 编码将实体分块传送并逐块表明长度，当长度为 `0` 是则代表传输结束
- 支持部分传输。当已经存在部分资源时，客户端可通过 `range` 头来告知服务端要获取哪些部分的资源，服务端返回 `Content-Range` 来表示这部分对象的偏移量和长度。如果服务端正确返回了对应的资源，状态码返回 `206`
- 增加缓存策略相关头部。`Cache-Control`、`ETag`、`If-Modified`...
- 引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。
- 增加 `Host` 请求头

#### v2.0

`http 1.x` 是超文本协议，`2.0` 是二进制协议


- 二进制分帧。当客户端同时向服务端发起多个请求，这些请求会被分解为一个个数据帧，在 `TCP` 链路中无序传输，同一个请求的帧的流标识是一样的，服务端根据流标识组合成一个完整的请求。（客户端发出的数据流ID为奇数，服务器为偶数）

- 服务端推流。服务端可以猜测客户端的需要，主动推送资源到客户端。


- 优先权。客户端通过依赖和权重给流设置优先级，优先级可以动态改变。服务端根据优先级进行资源分配。
- 头部压缩。多次请求和响应头部带有大量信息，而大多数的时候都是一样的。`2.0` 里将头部维护为两份字典：一份是静态字典，包含常见头部名称与值的组合代码；一份是可动态添加内容的动态字典；客户端和服务端各自维护这两份字典；字典只有在头部有改动时才会更新。避免了重复头部的传输，减少了需要传输的大小。(哈夫曼编码压缩)

  > 动态字典有大小限制，当新项被增加时，旧项会被删除

- 多路复用。多个请求采用同一个 `TCP` 连接，多个请求随机混杂在一起，服务端也不需要遵守请求顺序，并行执行，避免了队头阻塞问题

#### v2.0 和 SPDY 关系

`v2.0` 基于 `SPDY`, 但不强制必须用 `https`。不过大部分浏览器依旧规定只有 `https` 才支持 `v2.0`



#### 参考

- [HTTP的发展](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP)

## https

### 与 http 的区别

- `http` 采用明文传输，`https` 是密文传输
- `https` 在 `http` 基础上增加了一层会话层协议(`SSL` 或 `TSL`)
- 协议不同，端口不同。`http` 默认端口 `80`，`https` 默认端口为 `443`



`https` 如何加密过程:

0. 客户端与服务端采用非对称加密各自生成自己的公钥和私钥
1. 客户端与服务端互换公钥
2. 客户端与服务端通过对方的公钥加密信息并发送，双方收到后以各自的私钥解密，从而保证通信



上述的流程存在两个问题:

1. 加密方式为非对称加密，算法相对复杂，每次加密&解密所耗费的时间过长
2. 存在中间人攻击。中间人自己生成一对公钥&私钥，在首次客户端与服务端交换公钥的过程中，将双方的公钥统一替换成自己的公钥。客户端与服务端在不知情的情况下，会用中间人的公钥来加密信息，这些信息中间人都可以通过自身的私钥来解密进而窃取与篡改。



解决方案:

1. 信息的加密方式改为对称加密
2. 引入 CA 权威机构来验证合法性。
   1. 服务端将自身公钥和申请信息发送给 CA 申请证书，CA 机构确认申请人的合法性无误后返回证书（证书由服务端申请信息和服务端公钥加密而来）以及 CA 的公钥。
   2. 服务端将证书和 CA 公钥发送给客户端，客户端通过本地（浏览器和操作系统会维护权威的CA机构）维护的 CA 信息验证证书合法性，验证无误后通过本地维护的 CA 私钥将证书解密，验证其他信息 & 拿到服务器公钥。客户端通过服务端公钥将用于“对称加密的密钥“进行加密，服务端收到后用自身私钥解密拿到“对称加密的密钥”，后续客户端和服务端通过这个“对称加密的密钥”进行加密通信。

### TSL 协商 & HTTPS 加密过程

1. 客户端向服务端发送第一次请求，并携带信息：支持的 `TSL` 协议版本、支持的对称加密算法、随机数 A
2. 服务端接收到请求后，会根据客户端传递的信息，协商出最终的 `TSL` 协议版本和对称加密算法，并将这些信息与随机数 B 和 CA 证书一起返回
3. 客户端收到服务端返回的证书、协商结果、随机数 B
   1. 根据浏览器/系统内置的 CA 机构公钥校验该证书合法性
      1. 根据证书链逐级校验合法性
      2. 通过本地存储的 CA 机构的公钥将证书加密过后的签名解密，拿到签名 hash，然后根据同样的签名摘要算法，将证书明文部分进行签名，并将自己生成的签名与上述解密开来的签名 `hash` 进行比较，保证信息没被篡改
      3. 根据证书内的域名和证书有效期判断证书是否可信任
   2. 证书无误后，拿到证书里存放着的服务器公钥，通过该公钥加随机数 C 进行加密，传输给服务端。同时自身根据协商好的对称加密算法，对 随机数 A + B + C 进行加密，得到最终的“对称加密密钥”
4. 服务端收到公钥加密的随机数 C，用自己的私钥解开，并采用协商好的加密算法也将随机数 A + B + C 加密，得到与客户端一样的“对称加密的密钥”，后续通信的内容就通过该密钥加密通信。

> 服务端申请证书过程:
>
> 1. 服务端将自身机构/企业信息以及公钥发给权威 CA 机构
> 2. CA 机构通过线上/线下各种有效的手段验证该服务器的合法性
> 3. 如果确认无误后，CA 机构将证书所有者信息、CA机构信息、服务器公钥、签名所用算法、指纹以及指纹算法、证书有效期等等信息明文存放在证书里，同时根据这些明文信息进行签名生成 hash，通过自身的私钥将 hash 加密，最终返回给服务端最终的证书

#### 参考

- [SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)
- [彻底搞懂HTTPS的加密机制](https://zhuanlan.zhihu.com/p/43789231)

#### https 的缺点

- 多次握手会使页面加载时间延长近 50%，还会影响缓存，增加数据开销和功耗
- 涉及到的加密算法增加了 CPU 的开销，对服务器的资源占用较大
- 申请证书一般需要收费，功能越强大的证书费用越昂贵



### Cookie

可选字段:

- `domain`
- `path`
- `expired`
- `httponly`
- `secure`
  - 只允许 `https` 携带
- `samesite`  只发送相同站点(当前网页 url 与请求 url 是否一致)的 `cookie`
  - `strict`
    - 如果不一致，不携带此 `cookie`
  - `lax`
    - 允许导航到目标网址(比如 `a` 链接跳转到第三方站点)的 `get` 请求携带此 `cookie`，其余请求不携带
  - `none`
    - 不做限制
    - 只有 `https` 的请求才支持 `none` 值




## 参考链接

- [HTTP协议知识点总结](https://ddduanlian.github.io/2018/06/22/http_note/)
- [HTTP/1.x 的连接管理](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x)
- [理解浏览器缓存以及304状态码](https://juejin.im/post/5a142fab6fb9a044fb076322)
- [HTTP协议几个版本的比较](https://zhuanlan.zhihu.com/p/37387316)
- [HTTP1.0、HTTP1.1 和 HTTP2.0 的区别](https://juejin.im/entry/5981c5df518825359a2b9476)
- [漫画：什么是 HTTPS 协议？](https://zhuanlan.zhihu.com/p/57142784)
- [Cookie 的 SameSite 属性](https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html)
- [(建议收藏)TCP协议灵魂之问，巩固你的网路底层基础](https://juejin.im/post/5e527c58e51d4526c654bf41)
- [HTTP/2 头部压缩技术介绍](https://imququ.com/post/header-compression-in-http2.html)
- [HPACK: HTTP/2 里的沉默杀手（新特性）](https://www.zcfy.cc/article/hpack-the-silent-killer-feature-of-http-2-1969.html)

